#include<iostream>
#include<queue>
#include<vector>
using namespace std;

int dx[4] = { 0,0,1,-1 };
int dy[4] = { -1,1,0,0 };
class son_info {
public:
	int startx;
	int starty;
	int destx;
	int desty;
	int far;
};
bool flag = false;
int n, m, fuel,sons=0;
queue<pair<int, int> > son;
int carx, cary;
int map[21][21];
vector<son_info> info;
int vst[21][21];
void print() {
	for (int i = 0;i < n;i++) {
		for (int j = 0;j < n;j++) {
			cout << map[i][j] << " ";
		}cout << endl;
	}//map을 초기화 한다.

	for (int i = 0;i < m;i++) {
		cout << info[i].destx << " " << info[i].desty << endl;
	}
}
void vstinit() {
	for (int i = 0;i < 21;i++) {
		for (int j = 0;j < 21;j++) {
			vst[i][j] = 0;
		}
	}
}
void get() {
	cin >> n >> m >> fuel;//기본 map의 크기와 손님의 수, 차량의 첫 연료를 입력한다
	for (int i = 0;i < n;i++) {
		for (int j = 0;j < n;j++) {
			cin >> map[i][j];
		}
	}//map을 초기화 한다.

	cin >> carx >> cary; //차량의 현재 위치 입력
	carx -= 1;
	cary -= 1;
	int a, b, c, d;
	int count = 2;
	son_info  k;
	//손님이 있으면 2부터 시작 -> info의 index = 0은 map에서 2와 마찬가지
	for (int i = 0;i < m;i++) {
		cin >> a >> b >> c >> d;
		map[a - 1][b - 1] = count;
		k.destx = c - 1;
		k.desty = d - 1;
		k.startx = a - 1;
		k.starty = b - 1;
		info.push_back(k);
		count++;
	}

}//print 하여 입력 확인


void go(int idx) {
	vstinit();
	int stx = info[idx].startx;
	int sty = info[idx].starty;
	int dsx = info[idx].destx;
	int dsy = info[idx].desty;

	
	queue<pair<int, pair<int, int> >> q;
	q.push(make_pair(0, make_pair(stx, sty)));
	int needs = 100000;
	vst[stx][sty] = 1;
	while (!q.empty()) {
		int dis = q.front().first;
		int x = q.front().second.first;
		int y = q.front().second.second;
		q.pop();
		if (x == dsx && y == dsy) {
			needs = dis;
			break;
		}
		for (int i = 0;i < 4;i++) {
			int nx = x + dx[i];
			int ny = y + dy[i];

			if (nx < 0 || nx >= n || ny < 0 || ny >= n) {
				continue;
			}
			if (vst[nx][ny] == 1 || map[nx][ny] == 1)continue;
			vst[nx][ny] = 1;
			q.push(make_pair(dis + 1, make_pair(nx, ny)));
		}
	}



	if (needs > fuel) {
		flag = true;
		return;
	}
	fuel -= needs;
	fuel += needs * 2;
	map[stx][sty] = 0;
	sons += 1;
	carx = dsx;
	cary = dsy;
}
void bfs() {
	queue<pair<int,pair<int, int> >> q;
	vstinit();
	vst[carx][cary] = 1;
	q.push(make_pair(0,make_pair(carx, cary)));
	int checkcount = -1;
	int far = 1000000000;
	while (!q.empty()) {
		int dis = q.front().first;
		int x = q.front().second.first;
		int y = q.front().second.second;
		q.pop();
		for (int i = 0;i < 4;i++) {
			int nx = x + dx[i];
			int ny = y + dy[i];
			
			if (nx < 0 || nx >= n || ny < 0 || ny >= n) {
				continue;
			}
			if (map[nx][ny] == 1 || vst[nx][ny] == 1) {
				continue;
			}
			vst[nx][ny] = 1;
			if (map[nx][ny] == 0) {
				q.push(make_pair(dis+1,make_pair(nx, ny)));
				continue;
			}
			//cout << "A" << " " << nx << " " << ny << " " << carx << " " << cary << endl;;
			int checkfar = dis+1;

			if (checkfar < far) { 
				far = checkfar;
				checkcount = map[nx][ny];
			}
			else if (checkfar == far) {
				if (nx < x) {
					far = checkfar;
					checkcount = map[nx][ny];
				}
				else if (nx == x) {
					if (ny < y) {
						far = checkfar;
						checkcount = map[nx][ny];
					}
				}
			}
		}

	}

	if (far > fuel) {
		flag = true;
		return;
	}
	fuel -= far;
	//cout << far<<" "<<fuel << endl;
	go(checkcount - 2);
}


int main() {
	get();
	while (true) {
		if (sons == info.size()) { 
			cout << fuel;
			break; 
		}
		if (flag) { 
			cout << -1;
			break;
		}
		bfs();
	}
	return 0;
}

//수정전


문제점 
1. 너무 긴 코드 ( 생각나는 것을 정리해서 구현해야 한다 )
2. 반례 
( 도착점이 시작점이 될 수 있다 )
